import crypto from "node:crypto";
import { mkdir, writeFile } from "node:fs/promises";
import { join } from "node:path";
import type { RepoAnalysis, Skill, SkillBundle } from "./types.js";

/**
 * Generate portable Markdown skills from a repository analysis.
 */

function mdList(items: string[]): string {
  if (!items.length) return "- (none detected)";
  return items.map((i) => `- ${i}`).join("\n");
}

export function generateSkill(params: {
  analysis: RepoAnalysis;
  skillName?: string;
  description?: string;
}): Skill {
  const id = crypto.randomUUID();
  const createdAt = new Date().toISOString();
  const a = params.analysis;

  const sapSection = a.detected.sap.length
    ? `\n## SAP-Specific Guidance\n\nDetected SAP signals:\n${mdList(a.detected.sap)}\n\n### CAP Notes\n- If this is a CAP project, prefer \`cds build\` and \`cds deploy\` workflows.\n- Look for service definitions in \`srv/\` and data models in \`db/\`.\n\n### BTP Notes\n- Verify bindings for XSUAA/Destination/Connectivity.\n- Use MTA for Cloud Foundry deployments when present.\n`
    : "";

  const markdown = `# SKILL: ${params.skillName ?? a.name}\n\n${params.description ?? "Repository skill generated by Cortex Enterprise."}\n\n## Repository\n- Name: ${a.name}\n- Root: ${a.root}\n- Generated: ${createdAt}\n\n## Tech Stack\n\n### Languages\n${mdList(a.detected.languages)}\n\n### Runtimes\n${mdList(a.detected.runtimes)}\n\n### Frameworks\n${mdList(a.detected.frameworks)}\n\n### Databases\n${mdList(a.detected.databases)}\n\n### CI/CD\n${mdList(a.detected.cicd)}\n\n## Architecture (Heuristics)\n- Identify entrypoints (server bootstrap, handlers, jobs).\n- Map integration points (Jira/GitHub/Confluence/Graph, DB).\n- Locate config files (env, yaml, helm, mta).\n\n## Common Tasks\n- Build / run locally\n- Add a new endpoint / service\n- Update a DB model or migration\n- Run tests and CI\n- Troubleshoot production errors\n\n## Debugging Playbook\n1. Reproduce with minimal input; capture logs.\n2. Identify the failing subsystem (API, DB, integration, auth).\n3. Check CI/CD logs and environment variables.\n4. Add structured logs around boundaries.\n5. Verify permissions / RBAC / approvals when blocked.\n\n## Key Files & Signals\n${a.files
    .slice(0, 80)
    .map((m) => `- ${m.path} (${m.kind})${m.hints?.length ? ` â€” ${m.hints.join(", ")}` : ""}`)
    .join("\n")}\n\n## Suggested Next Steps\n- Confirm detected stack from README and configs.\n- Add missing docs to the knowledge base.\n- Generate runbooks for CI/CD and deployments.\n${sapSection}`;

  return {
    id,
    name: params.skillName ?? a.name,
    description: params.description ?? "Portable AI instructions for this repository.",
    createdAt,
    repo: { name: a.name, root: a.root },
    markdown,
  };
}

export function generateSkillBundle(params: { name: string; skills: Skill[]; meta?: Record<string, unknown> }): SkillBundle {
  return {
    id: crypto.randomUUID(),
    name: params.name,
    createdAt: new Date().toISOString(),
    skills: params.skills,
    meta: params.meta,
  };
}

/**
 * Write SKILL.md to the repo root (or specified output directory).
 */
export async function writeSkillMarkdown(params: {
  rootDir: string;
  markdown: string;
  filename?: string;
}): Promise<string> {
  const filename = params.filename ?? "SKILL.md";
  const outPath = join(params.rootDir, filename);
  await mkdir(params.rootDir, { recursive: true });
  await writeFile(outPath, params.markdown, "utf-8");
  return outPath;
}
